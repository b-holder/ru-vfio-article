Это перевод статьи "IOMMU groups, inside and out" - http://vfio.blogspot.nl/2014/08/iommu-groups-inside-and-out.html

Дата публикации оригинальной статьи - 25.08.2014. С тех пор многое изменилось, но так как статья по большей части теоретическая - кардинальных изменений мало.
Если что-то есть, о чём я не упомянул, значит я об этом забыл. :(

---

IOMMU группы, внутри и снаружи.

Иногда пользователи VFIO сталкиваются с непониманием причины невозможности разделения устройств между хост-системой и гостевой системой, или между несколькими гостями, являющейся разделением устройств на группы IOMMU(Input/Output Memory Management Unit). В таком случае, пользователи либо используют устаревший способ проброса устройств, либо в случае с многими пользователями VFIO - применяют патч обхода PCIe ACS(Access Control Services) (PCIe ACS override patch) чтобы обойти проблему.  Давайте посмотрим что же на самом деле происходит.

Надеюсь, мы все более-менее знаем что IOMMU делает в системе. Он позволяет отобразить(map) некий виртуальный адрес ввода вывода (I/O virtual address (IOVA)) на физическому адресу в памяти. Без IOMMU, все устройства видят физическую память плоской без какой-либо трансляции. С IOMMU появляется новое адресное пространство, IOVA, которое можно использовать.

Разные IOMMU работают по разному. До зарождения виртуализации, IOMMU чаще всего предоставляли только трансляцию, и часто лишь маленького окна адресного пространства. Большинство подобных IOMMU предоставляли две функции: избавление от bounce buffer'ов и создание протяжённых(contiguous) операций DMA(Direct Memory Access). Bounce buffer'ы нужны когда возможности устройства меньше чем платформы, например когда устройство может адресовать только 4 GB памяти, а платформа поддерживает 8 GB. Если драйвер выделит буффер выше чем 4GB, устройство не сможет делать DMA прямо в него. Bounce buffer это буфферная область памяти в нижнем регионе, куда устройство может временно делать DMA запросы, которые затем по выполнению копируются в выделенный драйвером буффер. IOMMU может помочь избежать лишние буффер и операцию копирования, предоставляя IOVA в рамках адресного пространства устройства(менее 4GB), опираясь на буффер драйвера, находящегося за пределами этого пространства. Создание протяжённых DMA операций особенно полезно когда драйвер использует несколько буфферов, разбросанных (scatter) по физической памяти, и собрирает их (gather) вместе для единой операции ввода-вывода. IOMMU может взять эти scatter-gather списки и отобразить их в пространство IOVA таким образом, что для устройства сформируется одна протяжённая DMA операция. Простейший пример - драйвер выделил два 4KB буффера в разных областях физической памяти. IOMMU выделяет протяжённый диапазон для этих буфферов, позволяя устройство сделать одну 8 килобайтную DMA-операцию вместо двух 4 килобайтных.

Обе этих функции по прежнему очень важны для быстродейстующего ввода-вывода на хост-системе, но с точки зрения виртуализации, любимая функция современных IOMMU - это изоляция между устройствами. Изоляция была по большей части невозможна до внедрения PCI-Express из-за того, что традиционная PCI шина не помечает транзакции идентификатором запрашивающего устройства(requester ID). В PCI-X было что-то подобное requester ID но правила по которым устройства овладевали транзакциями не позволяли изолировать устройства. На PCIe каждое устройство помечает транзакции уникальным requester IDом, (PCI bus/device/function, BDF. Например, 01:00.0 - первая шина,нулевое устройство, нулевая функция; 03:05.c - третья шина, пятое устройство, функция 0xc), по которому можно вычислить уникальную таблицу IOVA для данного устройства. Внезапно, мы перешли от общего пространства IOVA для доступа к недоступной памяти и объединения диапазонов к отдельному пространству IOVA для каждого устройства, которое мы можем использовать не только для тех функций, но и для изоляции DMA запросов устройств. Для проброса в виртуальную машину, нам нужно лишь наполнить пространство IOVA для назначаемого устройства соотношениями гостевой физической памяти к физической памяти хост-системы(выделенной под ВМ(ВиртуальнуюМашину)), и наше устройство может прозрачно делать DMA в гостевое адресное пространство.

Возвращаясь к IOMMU группам - это попытка определить наименьший набор устройств, которые можно считать изолированными с перспективы IOMMU. Первый шаг к этому - ассоциация каждого устройства с уникальным пространством IOVA. Таким образом, если несколько устройств относятся к одному пространству IOVA, IOMMU не может отличить их друг от друга. По этой причине на типичном x86 компьютере IOMMU сгруппирует все обычные PCI устройства в одну группу, так как они все относятся к одному PCI-to-PCIe мосту. Устаревший способ назначения устройств в KVM позволяет пользователю назначить такие устройства по отдельности, но такая конфигурация обречена на провал. VFIO же управляется IOMMU группами и таким образом предотвращает конфигурации нарушающие этот простейший принцип гранулярности IOMMU.
Помимо возможности хотя бы отличать одно устройство от другого, нам нужно ещё понимать какие транзакции вообще дойдут до IOMMU. Спецификации PCIe позволяют транзакциям быть перенаправленными внутри структуры соединения(interconnect fabric). Нижележащий(downstream) порт PCIe может перенаправить транзакцию от одного нижележащего устройства на другое. В свою очередь, порты PCIe свитча могут быть связаны таким образом, что возможно перенаправление с одного порта на другой. Даже внутри многофункционального конечного устройства, транзакция от одной функции может быть доставлена прямо к другой функции. Такие транзакции от одного устройства к другому называются peer-to-peer транзакциями и могут быть неприятными для устройств в разных пространствах IOVA. Представьте себе, сетевая карта назначенная гостю попыталась сделать DMA запрос на запись по гостевому физическому адресу(IOVA), который совпал с диапазоном MMIO(Memory Mapped Input/Output) контроллера дисков на хост-системе. Соединение, пытающееся оптимизировать маршрут транзакции послав DMA-запись напрямую в контроллер дисков до того как транзакция доберётся до IOMMU для трансляции адресов.

В этот момент в работу включается PCIe Access Control Services (ACS). ACS предоставляет возможность определить возможны ли подобные перенаправления, а также возможность запретить их. Это наиважнейший компонент для изоляции устройств друг от друга, и, к сожалению, наиболее рекдо встречающийсся в структуре соединения(мосты, свитчи, порты) и многофункциональных устройствах. Без поддержки ACS на каждом шагу от устройства до IOMMU, мы вынуждены предполагать что перенаправление возможно на самом высоколежащем(upstream) устройстве без ACS, таким образом нарушая изоляцию между устройствами ниже этой точки в топологии. IOMMU группы строятся с учётом этого, объединяя устройства способные к нетранслируемому peer-to-peer DMA.

Сочетая обе эти вещи, IOMMU группа представляет наименьший набор устройств, который видит IOMMU и который изолирован от других групп. VFIO испольует эту информацию чтобы заставить пользовательские программы использовать только безопасное назначение устройств. За исключением мостов, корневых портов и свитчей(структуры соединения, interconnect fabric), все устройства внутри IOMMU группы  должны быть привязаны(bind) к драйверу VFIO или затычке(stub). Для PCI, такими драйверами являются vfio-pci и pci-stub. Последний разрешён просто потому, что в его случае известно что хост-система не будет никак взаимодействовать с устройством через этот драйвер(лучше не использовать устаревший способ назначения устройств из KVM (pci-back) на устройствах внутри группы, особенно если группа используется VFIO для другой ВМ). Если попытавшись использовать VFIO вы увидели сообщение об ошибке "группа не жизнеспособна"(group is not viable) - оно относится именно к правилу назначения всех устройств внутри группы подходящему драйверу хост-системы.


Тут AW начинает разбирать на примере. Я пока не решился переводить его пример(у него всё-таки интел) или попробовать собрать свой(у меня девайсов больше, да и форматирование мне не нравится).

